"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6583],{9127:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>c,frontMatter:()=>s,metadata:()=>l,toc:()=>u});var r=t(4848),i=t(8453);const s={title:"Segment Tree Tutorial",description:"A comprehensive guide to Segment Trees with code examples in JavaScript."},a="Segment Tree Tutorial",l={id:"tutorial-basics/SegmentTree",title:"Segment Tree Tutorial",description:"A comprehensive guide to Segment Trees with code examples in JavaScript.",source:"@site/docs/tutorial-basics/SegmentTree.mdx",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/SegmentTree",permalink:"/js_enigma/docs/tutorial-basics/SegmentTree",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/tutorial-basics/SegmentTree.mdx",tags:[],version:"current",frontMatter:{title:"Segment Tree Tutorial",description:"A comprehensive guide to Segment Trees with code examples in JavaScript."},sidebar:"tutorialSidebar",previous:{title:"In-Place Reversal of a Linked List",permalink:"/js_enigma/docs/tutorial-basics/ReverseLinkedList"},next:{title:"Sliding Window Technique",permalink:"/js_enigma/docs/tutorial-basics/SlidingWindow"}},o={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Key Operations",id:"key-operations",level:2},{value:"Segment Tree Structure",id:"segment-tree-structure",level:2},{value:"Implementation",id:"implementation",level:2},{value:"1D Range Queries",id:"1d-range-queries",level:3},{value:"2D Range Queries",id:"2d-range-queries",level:3},{value:"Range Module",id:"range-module",level:3},{value:"Counting Problems",id:"counting-problems",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"segment-tree-tutorial",children:"Segment Tree Tutorial"})}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(n.p,{children:["A Segment Tree is a data structure used to efficiently perform range queries and updates on an array. It is particularly useful when you need to query the sum, minimum, maximum, or any associative operation over a range of elements in an array, and it supports these operations in ",(0,r.jsx)(n.code,{children:"O(log n)"})," time."]}),"\n",(0,r.jsx)(n.h2,{id:"key-operations",children:"Key Operations"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Build"}),": Construct the Segment Tree from an array."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Update"}),": Update a specific element in the array and reflect this change in the Segment Tree."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Query"}),": Query a specific range of the array for a sum, minimum, maximum, or any other associative function."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"segment-tree-structure",children:"Segment Tree Structure"}),"\n",(0,r.jsx)(n.p,{children:"A Segment Tree is typically represented as a binary tree, where each node represents a segment (or range) of the array. The leaf nodes represent individual elements, and the internal nodes represent the result of the function (like sum, min, max) applied to the segment."}),"\n",(0,r.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(n.p,{children:"Here\u2019s a basic implementation of a Segment Tree in JavaScript for range sum queries:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class SegmentTree {\n  constructor(arr) {\n    this.n = arr.length;\n    this.tree = new Array(2 * this.n);\n    this.build(arr);\n  }\n\n  // Build the Segment Tree\n  build(arr) {\n    // Insert leaf nodes in the tree\n    for (let i = 0; i < this.n; i++) {\n      this.tree[this.n + i] = arr[i];\n    }\n\n    // Build the tree by calculating parents\n    for (let i = this.n - 1; i > 0; i--) {\n      this.tree[i] = this.tree[i * 2] + this.tree[i * 2 + 1];\n    }\n  }\n\n  // Update the value at index i to newValue\n  update(index, newValue) {\n    index += this.n;\n    this.tree[index] = newValue;\n\n    // Recalculate the values in the tree\n    while (index > 1) {\n      index = Math.floor(index / 2);\n      this.tree[index] = this.tree[2 * index] + this.tree[2 * index + 1];\n    }\n  }\n\n  // Query the sum of values in range [left, right)\n  query(left, right) {\n    left += this.n; // add +1 to make the left query exclusive\n    right += this.n; // add +1 to make the query right inclusive\n    let sum = 0;\n\n    while (left < right) {\n      if (left % 2 === 1) {\n        sum += this.tree[left];\n        left++;\n      }\n      if (right % 2 === 1) {\n        right--;\n        sum += this.tree[right];\n      }\n      left = Math.floor(left / 2);\n      right = Math.floor(right / 2);\n    }\n\n    return sum;\n  }\n}\n\n// Example Usage\nconst arr = [1, 3, 5, 7, 9, 11];\nconst segTree = new SegmentTree(arr);\n\n// Querying the sum from index 1 to 4 (3 + 5 + 7)\nconsole.log(segTree.query(1, 4)); // Output: 15\n\n// Updating the value at index 2 to 6\nsegTree.update(2, 6);\n\n// Querying the sum from index 1 to 4 again (3 + 6 + 7)\nconsole.log(segTree.query(1, 4)); // Output: 16\n"})}),"\n",(0,r.jsx)(n.h1,{id:"range-queries-problems",children:"Range Queries Problems"}),"\n",(0,r.jsx)(n.h3,{id:"1d-range-queries",children:"1D Range Queries"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/range-sum-query-mutable/description/",children:"Range Sum Query - Mutable"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/range-sum-query-immutable/description/",children:"Range Sum Query - Immutable"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2d-range-queries",children:"2D Range Queries"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/range-sum-query-2d-mutable/description/",children:"Range Sum Query 2D - Mutable"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"range-module",children:"Range Module"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/range-module/description/",children:"Range Module"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"counting-problems",children:"Counting Problems"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/count-of-smaller-numbers-after-self/",children:"Count of Smaller Numbers After Self"})}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var r=t(6540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);