"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8745],{1488:(n,r,e)=>{e.r(r),e.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var t=e(4848),a=e(8453);const s={title:"Backtracking Algorithm"},i=void 0,o={id:"tutorial-basics/Backtracking",title:"Backtracking Algorithm",description:"Backtracking Algorithm",source:"@site/docs/tutorial-basics/Backtracking.mdx",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/Backtracking",permalink:"/js_enigma/docs/tutorial-basics/Backtracking",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/tutorial-basics/Backtracking.mdx",tags:[],version:"current",frontMatter:{title:"Backtracking Algorithm"},sidebar:"tutorialSidebar",previous:{title:"Breadth-First Search (BFS) for Trees",permalink:"/js_enigma/docs/tutorial-basics/BFSTree"},next:{title:"Binary Search and Its Variants",permalink:"/js_enigma/docs/tutorial-basics/BinarySearch"}},c={},l=[{value:"Backtracking Algorithm",id:"backtracking-algorithm",level:2},{value:"Overview",id:"overview",level:3},{value:"Algorithm Steps",id:"algorithm-steps",level:3},{value:"Example Implementation",id:"example-implementation",level:3},{value:"Permutation",id:"permutation",level:3},{value:"Permutation 2",id:"permutation-2",level:3},{value:"Combination",id:"combination",level:3},{value:"Combination Sum",id:"combination-sum",level:3},{value:"Combination 3",id:"combination-3",level:3},{value:"Subsets",id:"subsets",level:3},{value:"Subsets 2",id:"subsets-2",level:3}];function u(n){const r={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h2,{id:"backtracking-algorithm",children:"Backtracking Algorithm"}),"\n",(0,t.jsx)(r.p,{children:"The Backtracking algorithm is a general technique used for solving problems by incrementally building solutions and abandoning those that fail to meet the criteria. It explores all possible solutions in a systematic manner and is particularly useful for constraint satisfaction and combinatorial problems."}),"\n",(0,t.jsx)(r.h3,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(r.p,{children:"Backtracking works by trying out all potential solutions and discarding those that do not meet the problem\u2019s constraints. It builds a solution step-by-step, and if at any step the current solution does not meet the constraints, it backtracks to the previous step and tries a different option."}),"\n",(0,t.jsx)(r.h3,{id:"algorithm-steps",children:"Algorithm Steps"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Choose"}),": Select an option from the available choices."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Explore"}),": Move to the next state or option based on the current choice."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Check"}),": Determine if the current state meets the constraints or criteria of the problem."]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Backtrack"}),": If the current solution path does not meet the criteria, revert to the previous state and try the next option."]}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"example-implementation",children:"Example Implementation"}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Code Example"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-javascript",children:"/**\r\n * Solve [Problem Description] using Backtracking.\r\n * @param {Type} [parameterName] - [Description of the parameter]\r\n * @return {Type} - [Description of the return value]\r\n */\r\nconst [functionName] = ([parameters]) => {\r\n  const result = [];\r\n  \r\n  const backtrack = (currentState) => {\r\n    // Base case: Check if current state meets the criteria\r\n    if ([condition]) {\r\n      result.push([solution]);\r\n      return;\r\n    }\r\n    \r\n    // Iterate through options and recurse\r\n    for (const option of [options]) {\r\n      if ([isValid](option)) {\r\n        // Make a choice\r\n        [updateState](option);\r\n        \r\n        // Recur to explore the next step\r\n        backtrack([newState]);\r\n        \r\n        // Undo the choice (backtrack)\r\n        [revertState](option);\r\n      }\r\n    }\r\n  };\r\n\r\n  backtrack([initialState]);\r\n  return result;\r\n};\r\n\r\n// Example usage:\r\nconsole.log([functionName]([testParameters]));\r\n/* Output:\r\n[Expected output]\r\n*/\n"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.strong,{children:"Code Example"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:"/**\r\n * Solve the N-Queens problem using Backtracking.\r\n * @param {number} n - The size of the chessboard (n x n).\r\n * @return {number[][]} - All possible solutions to the N-Queens problem.\r\n */\r\nconst solveNQueens = (n) => {\r\n  const result = [];\r\n  const board = Array(n).fill().map(() => Array(n).fill('.'));\r\n  \r\n  const isSafe = (row, col) => {\r\n    // Check the column and diagonals\r\n    for (let i = 0; i < row; i++) {\r\n      if (board[i][col] === 'Q') return false;\r\n      if (col - (row - i) >= 0 && board[i][col - (row - i)] === 'Q') return false;\r\n      if (col + (row - i) < n && board[i][col + (row - i)] === 'Q') return false;\r\n    }\r\n    return true;\r\n  };\r\n  \r\n  const backtrack = (row) => {\r\n    if (row === n) {\r\n      result.push(board.map(r => r.join('')));\r\n      return;\r\n    }\r\n    for (let col = 0; col < n; col++) {\r\n      if (isSafe(row, col)) {\r\n        board[row][col] = 'Q';\r\n        backtrack(row + 1);\r\n        board[row][col] = '.'; // Undo the move\r\n      }\r\n    }\r\n  };\r\n\r\n  backtrack(0);\r\n  return result;\r\n};\r\n\r\n// Example usage:\r\nconsole.log(solveNQueens(4));\r\n/* Output:\r\n[\r\n  [ '.Q..',  '...Q',  'Q...',  '..Q.' ],\r\n  [ '..Q.',  'Q...',  '...Q',  '.Q..' ]\r\n]*/\n"})}),"\n",(0,t.jsx)(r.h3,{id:"permutation",children:"Permutation"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:"const permute = (nums) => {\r\n  const result = [];\r\n  const backtrack = (path) => {\r\n    if (path.length === nums.length) {\r\n      result.push([...path]);\r\n      return;\r\n    }\r\n    for (let i = 0; i < nums.length; i++) {\r\n      if (path.includes(nums[i])) continue;\r\n      path.push(nums[i]);\r\n      backtrack(path);\r\n      path.pop();\r\n    }\r\n  };\r\n\r\n  backtrack([]);\r\n  return result;\r\n};\n"})}),"\n",(0,t.jsx)(r.h3,{id:"permutation-2",children:"Permutation 2"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:"const permuteUnique = (nums) => {\r\n  const list = []\r\n  nums.sort((a, b) => a - b); // Sort the array to ensure duplicates are adjacent\r\n\r\n  const backtrack = (tempList, used) => {\r\n    if (tempList.length === nums.length) {\r\n      list.push([...tempList]);\r\n      return\r\n    }\r\n    for (let i = 0; i < nums.length; i++) {\r\n      // Skip the used elements or duplicates\r\n      if (used[i] || (i > 0 && nums[i] === nums[i - 1] && !used[i - 1])) continue;\r\n      used[i] = true;\r\n      tempList.push(nums[i]);\r\n      backtrack(tempList, used);\r\n      used[i] = false;\r\n      tempList.pop();\r\n    }\r\n  };\r\n\r\n  backtrack([], new Array(nums.length).fill(false));\r\n  return list;\r\n};\n"})}),"\n",(0,t.jsx)(r.h3,{id:"combination",children:"Combination"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:"/**\r\n * @param {number} n\r\n * @param {number} k\r\n * @return {number[][]}\r\n */\r\nconst combine = (n, k) => {\r\n  const res = []\r\n\r\n  const backtrack = (index, comb) => {\r\n    if (comb.length === k) {\r\n      res.push([...comb])\r\n      return\r\n    }\r\n    for (let i = index; i < n + 1; i++) {\r\n      comb.push(i)\r\n      backtrack(i + 1, comb)\r\n      comb.pop()\r\n    }\r\n  }\r\n  backtrack(1, [])\r\n  return res\r\n};\n"})}),"\n",(0,t.jsx)(r.h3,{id:"combination-sum",children:"Combination Sum"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:"/**\r\n * @param {number[]} candidates\r\n * @param {number} target\r\n * @return {number[][]}\r\n */\r\nconst combinationSum = (candidates, target) => {\r\n  const result = [];\r\n\r\n  const backtrack = (start, path, sum) => {\r\n    if (sum > target) return; // Exceeds the target, no need to continue\r\n    if (sum === target) { // Found a valid combination\r\n      result.push([...path]);\r\n      return;\r\n    }\r\n    for (let i = start; i < candidates.length; i++) {\r\n      path.push(candidates[i]); // Choose the candidate\r\n      backtrack(i, path, sum + candidates[i]); // Recur with the same candidate\r\n      path.pop(); // Backtrack, remove the last candidate\r\n    }\r\n  };\r\n\r\n  backtrack(0, [], 0); // Start with index 0, empty path, and sum 0\r\n  return result;\r\n};\n"})}),"\n",(0,t.jsx)(r.h3,{id:"combination-3",children:"Combination 3"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:"/**\r\n * @param {number} k\r\n * @param {number} n\r\n * @return {number[][]}\r\n */\r\nconst combinationSum3 = (k, n) => {\r\n  const result = []\r\n\r\n  const backtrack = (start, path, sum) => {\r\n    if (path.length === k && sum === n) {\r\n      result.push([...path])\r\n      return\r\n    }\r\n\r\n    if (sum >= n && path.length >= k) return\r\n\r\n    for (let i = start; i <= 9; i++) {\r\n      path.push(i)\r\n      backtrack(i + 1, path, sum + i)\r\n      path.pop(i)\r\n    }\r\n  }\r\n\r\n  backtrack(1, [], 0)\r\n  return result\r\n};\n"})}),"\n",(0,t.jsx)(r.h3,{id:"subsets",children:"Subsets"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:"/**\r\n * @param {number[]} nums\r\n * @return {number[][]}\r\n */\r\nconst subsets = (nums) => {\r\n  const result = []\r\n\r\n  const backtrack = (id, subs) => {\r\n    result.push([...subs])\r\n\r\n    for (let i = id; i < nums.length; i++) {\r\n      subs.push(nums[i])\r\n      backtrack(i + 1, subs)\r\n      subs.pop()\r\n    }\r\n  }\r\n  backtrack(0, [])\r\n  return result\r\n};\n"})}),"\n",(0,t.jsx)(r.h3,{id:"subsets-2",children:"Subsets 2"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-Javascript",children:"/**\r\n * @param {number[]} nums\r\n * @return {number[][]}\r\n */\r\nconst subsetsWithDup = (nums) => {\r\n  nums.sort((a, b) => a - b)\r\n  const result = []\r\n\r\n  const backtrack = (id, subs) => {\r\n    result.push([...subs])\r\n\r\n    for (let i = id; i < nums.length; i++) {\r\n      if (i > id && nums[i] === nums[i - 1]) continue\r\n      subs.push(nums[i])\r\n      backtrack(i + 1, subs)\r\n      subs.pop()\r\n    }\r\n  }\r\n  backtrack(0, [])\r\n  return result\r\n};\n"})})]})}function m(n={}){const{wrapper:r}={...(0,a.R)(),...n.components};return r?(0,t.jsx)(r,{...n,children:(0,t.jsx)(u,{...n})}):u(n)}},8453:(n,r,e)=>{e.d(r,{R:()=>i,x:()=>o});var t=e(6540);const a={},s=t.createContext(a);function i(n){const r=t.useContext(s);return t.useMemo((function(){return"function"==typeof n?n(r):{...r,...n}}),[r,n])}function o(n){let r;return r=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:i(n.components),t.createElement(s.Provider,{value:r},n.children)}}}]);