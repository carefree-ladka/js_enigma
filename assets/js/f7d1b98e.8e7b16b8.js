"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9125],{3064:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var t=r(4848),s=r(8453);const a={title:"K-Way Merge Pattern"},i="K-Way Merge Pattern",l={id:"tutorial-basics/KWayMerge",title:"K-Way Merge Pattern",description:"The k-way merge pattern is a technique used to merge k sorted arrays (or linked lists) into a single sorted array. It's commonly used in problems like merging multiple sorted arrays, finding the smallest range covering elements from k lists, and more.",source:"@site/docs/tutorial-basics/KWayMerge.mdx",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/KWayMerge",permalink:"/docs/tutorial-basics/KWayMerge",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/tutorial-basics/KWayMerge.mdx",tags:[],version:"current",frontMatter:{title:"K-Way Merge Pattern"},sidebar:"tutorialSidebar",previous:{title:"Knuth-Morris-Pratt (KMP) Algorithm",permalink:"/docs/tutorial-basics/KMPAlgo"},next:{title:"Kadane's Algorithm Tutorial",permalink:"/docs/tutorial-basics/Kadane"}},o={},c=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach",id:"approach",level:2},{value:"Example",id:"example",level:3},{value:"Steps",id:"steps",level:3},{value:"Code Implementation",id:"code-implementation",level:3},{value:"Complexity Analysis",id:"complexity-analysis",level:3},{value:"Use Cases",id:"use-cases",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"k-way-merge-pattern",children:"K-Way Merge Pattern"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"k-way merge"})," pattern is a technique used to merge ",(0,t.jsx)(n.code,{children:"k"})," sorted arrays (or linked lists) into a single sorted array. It's commonly used in problems like merging multiple sorted arrays, finding the smallest range covering elements from ",(0,t.jsx)(n.code,{children:"k"})," lists, and more."]}),"\n",(0,t.jsx)(n.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,t.jsxs)(n.p,{children:["Given ",(0,t.jsx)(n.code,{children:"k"})," sorted arrays, merge them into one sorted array."]}),"\n",(0,t.jsx)(n.h2,{id:"approach",children:"Approach"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Min-Heap:"})," We use a min-heap (or priority queue) to efficiently fetch the smallest element among the ",(0,t.jsx)(n.code,{children:"k"})," arrays."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Initialization:"})," Insert the first element of each array into the heap."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Merging:"})," Repeatedly extract the smallest element from the heap and add the next element from the same array to the heap until all elements are merged."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,t.jsxs)(n.p,{children:["Let's consider an example with ",(0,t.jsx)(n.code,{children:"k = 3"})," arrays:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-JavaScript",children:"const arrays = [\r\n  [1, 4, 5],\r\n  [1, 3, 4],\r\n  [2, 6]\r\n];\n"})}),"\n",(0,t.jsx)(n.p,{children:"We want to merge these arrays into a single sorted array."}),"\n",(0,t.jsx)(n.h3,{id:"steps",children:"Steps"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Insert First Elements:"})," Start by inserting the first element from each array into the heap:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Heap: ",(0,t.jsx)(n.code,{children:"[1, 1, 2]"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Extract Min:"})," Extract ",(0,t.jsx)(n.code,{children:"1"})," (smallest element) from the heap and insert the next element from the same array:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Heap: ",(0,t.jsx)(n.code,{children:"[1, 2, 4]"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Repeat:"})," Continue this process until all elements are merged."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"code-implementation",children:"Code Implementation"}),"\n",(0,t.jsx)(n.p,{children:"Here\u2019s a sample implementation in JavaScript:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-JavaScript",children:"function mergeKSortedArrays(arrays) {\r\n  const minHeap = new MinHeap();\r\n  const result = [];\r\n\r\n  // Initialize the heap with the first element of each array\r\n  for (let i = 0; i < arrays.length; i++) {\r\n    if (arrays[i].length > 0) {\r\n      minHeap.enequeue(arrays[i][0], i, 0);\r\n    }\r\n  }\r\n\r\n  while (minHeap.heap.length > 0) {\r\n    const { val, arrIndex, valIndex } = minHeap.dequeue();\r\n    result.push(val);\r\n    // If the array has more elements, add the next element to the heap\r\n    if (valIndex + 1 < arrays[arrIndex].length) {\r\n      minHeap.enequeue(arrays[arrIndex][valIndex + 1], arrIndex, valIndex + 1);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// Example usage\r\nconst arrays = [\r\n  [1, 4, 5],\r\n  [1, 3, 4],\r\n  [2, 6]\r\n];\r\nconst result = mergeKSortedArrays(arrays);\r\nconsole.log(result); // Output: [1, 1, 2, 3, 4, 4, 5, 6]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"complexity-analysis",children:"Complexity Analysis"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Time Complexity:"})," O(N log k), where ",(0,t.jsx)(n.code,{children:"N"})," is the total number of elements across all arrays and ",(0,t.jsx)(n.code,{children:"k"})," is the number of arrays."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Space Complexity:"})," O(k) for storing elements in the heap."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Merging multiple log files."}),"\n",(0,t.jsxs)(n.li,{children:["Finding the smallest range covering elements from ",(0,t.jsx)(n.code,{children:"k"})," sorted lists."]}),"\n",(0,t.jsx)(n.li,{children:"K-way merge in external sorting."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"The k-way merge pattern is a powerful technique for efficiently merging multiple sorted arrays. It leverages a min-heap to always extract the smallest element, ensuring that the resulting array is sorted."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>l});var t=r(6540);const s={},a=t.createContext(s);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);