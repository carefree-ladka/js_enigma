"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7195],{3420:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>l,frontMatter:()=>i,metadata:()=>a,toc:()=>h});var r=n(4848),s=n(8453);const i={title:"0-1 BFS Algorithm"},o=void 0,a={id:"tutorial-basics/01BFS",title:"0-1 BFS Algorithm",description:"0-1 BFS Algorithm",source:"@site/docs/tutorial-basics/01BFS.mdx",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/01BFS",permalink:"/docs/tutorial-basics/01BFS",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/tutorial-basics/01BFS.mdx",tags:[],version:"current",frontMatter:{title:"0-1 BFS Algorithm"},sidebar:"tutorialSidebar",previous:{title:"Data Structures & Algorithms",permalink:"/docs/category/data-structures--algorithms"},next:{title:"2D Matrix Graph Algorithms",permalink:"/docs/tutorial-basics/2DGraphAlgorithms"}},d={},h=[{value:"0-1 BFS Algorithm",id:"0-1-bfs-algorithm",level:2},{value:"Concept",id:"concept",level:3},{value:"Algorithm Steps",id:"algorithm-steps",level:3},{value:"Code Example",id:"code-example",level:3}];function c(e){const t={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"0-1-bfs-algorithm",children:"0-1 BFS Algorithm"}),"\n",(0,r.jsx)(t.p,{children:"0-1 BFS is a specialized version of the Breadth-First Search (BFS) algorithm designed to handle graphs where edge weights are either 0 or 1. It efficiently finds the shortest path in such graphs by leveraging a double-ended queue (deque) to maintain a more nuanced approach to edge weights."}),"\n",(0,r.jsx)(t.h3,{id:"concept",children:"Concept"}),"\n",(0,r.jsx)(t.p,{children:"In 0-1 BFS:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Edge Weights"}),": The edge weights are either 0 or 1."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Data Structure"}),": A double-ended queue (deque) is used to optimize the traversal. Nodes connected by an edge with weight 0 are added to the front of the deque, and nodes connected by an edge with weight 1 are added to the back."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Objective"}),": To find the shortest path from a source node to all other nodes in the graph."]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"algorithm-steps",children:"Algorithm Steps"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Initialize"}),": Start by initializing the distance for each node as infinity, except for the source node which is set to 0. Use a deque to manage the nodes to be processed."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Process Nodes"}),": Dequeue nodes and update their neighbors based on edge weights.","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"For an edge with weight 0, update the neighbor\u2019s distance and add it to the front of the deque."}),"\n",(0,r.jsx)(t.li,{children:"For an edge with weight 1, update the neighbor\u2019s distance and add it to the back of the deque."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Continue"}),": Repeat the process until all nodes are processed."]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"code-example",children:"Code Example"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"JavaScript Implementation"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"const { Deque } = require('collections/deque');\r\n\r\n/**\r\n * Compute the shortest path distances from the source node using 0-1 BFS.\r\n * @param {number[][]} graph - Adjacency list representation of the graph with edge weights 0 or 1.\r\n * @param {number} source - The source node.\r\n * @return {number[]} - Array of shortest path distances from the source.\r\n */\r\nconst zeroOneBFS = (graph, source) => {\r\n  const n = graph.length;\r\n  const distances = Array(n).fill(Infinity);\r\n  const deque = new Deque();\r\n\r\n  distances[source] = 0;\r\n  deque.pushFront(source);\r\n\r\n  while (deque.length > 0) {\r\n    const node = deque.shift();\r\n    \r\n    for (const [neighbor, weight] of graph[node]) {\r\n      const newDist = distances[node] + weight;\r\n      if (newDist < distances[neighbor]) {\r\n        distances[neighbor] = newDist;\r\n        if (weight === 0) {\r\n          deque.pushFront(neighbor);\r\n        } else {\r\n          deque.pushBack(neighbor);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return distances;\r\n};\n"})})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var r=n(6540);const s={},i=r.createContext(s);function o(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);