"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5598],{4656:(r,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var t=e(4848),i=e(8453);const s={title:"2D Matrix Graph Algorithms",description:"A comprehensive guide to 2D DFS, 2D BFS, and 2D Dijkstra algorithms with code examples in JavaScript."},o="2D Graph Algorithms Tutorial",a={id:"tutorial-basics/2DGraphAlgorithms",title:"2D Matrix Graph Algorithms",description:"A comprehensive guide to 2D DFS, 2D BFS, and 2D Dijkstra algorithms with code examples in JavaScript.",source:"@site/docs/tutorial-basics/2DGraphAlgorithms.mdx",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/2DGraphAlgorithms",permalink:"/js_enigma/docs/tutorial-basics/2DGraphAlgorithms",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/tutorial-basics/2DGraphAlgorithms.mdx",tags:[],version:"current",frontMatter:{title:"2D Matrix Graph Algorithms",description:"A comprehensive guide to 2D DFS, 2D BFS, and 2D Dijkstra algorithms with code examples in JavaScript."},sidebar:"tutorialSidebar",previous:{title:"0-1 BFS Algorithm",permalink:"/js_enigma/docs/tutorial-basics/01BFS"},next:{title:"Breadth-First Search (BFS) for Trees",permalink:"/js_enigma/docs/tutorial-basics/BFSTree"}},l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"2D Depth-First Search (DFS)",id:"2d-depth-first-search-dfs",level:2},{value:"Overview",id:"overview",level:3},{value:"Implementation",id:"implementation",level:3},{value:"2D Breadth-First Search (BFS)",id:"2d-breadth-first-search-bfs",level:2},{value:"2D Dijkstra (Shortest Path)",id:"2d-dijkstra-shortest-path",level:2}];function d(r){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...r.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"2d-graph-algorithms-tutorial",children:"2D Graph Algorithms Tutorial"})}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"In many problems involving grids or 2D matrices, algorithms designed for 2D graphs become crucial. These algorithms help in navigating and solving various tasks in grid-based problems. This tutorial covers three key algorithms used in 2D grids:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"2D Depth-First Search (DFS)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"2D Breadth-First Search (BFS)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"2D Dijkstra's Algorithm"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"2d-depth-first-search-dfs",children:"2D Depth-First Search (DFS)"}),"\n",(0,t.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"DFS explores as far as possible along each branch before backtracking. In a 2D grid, DFS can be used to traverse and solve problems like connected components or island counting."}),"\n",(0,t.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsx)(n.p,{children:"Here\u2019s a JavaScript implementation of 2D DFS:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-JavaScript",children:"function dfs(grid, row, col, visited) {\r\n  // Check boundaries and if the cell is already visited\r\n  if (\r\n    row < 0 || row >= grid.length ||\r\n    col < 0 || col >= grid[0].length ||\r\n    visited[row][col]\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  // Mark the cell as visited\r\n  visited[row][col] = true;\r\n\r\n  // Print the current cell's value\r\n  console.log(grid[row][col]);\r\n\r\n  // Define the directions for traversal: right, down, left, up\r\n  const directions = [\r\n    [0, 1],    // right\r\n    [1, 0],    // down\r\n    [0, -1],   // left\r\n    [-1, 0],   // up\r\n    [1, 1],    // down-right (diagonal)\r\n    [1, -1],   // down-left (diagonal)\r\n    [-1, 1],   // up-right (diagonal)\r\n    [-1, -1]   // up-left (diagonal)\r\n  ];\r\n\r\n  // Explore all neighbors\r\n  for (let [dr, dc] of directions) {\r\n    dfs(grid, row + dr, col + dc, visited);\r\n  }\r\n}\r\n\r\n// Example usage:\r\nconst grid = [\r\n  [1, 2, 3],\r\n  [4, 5, 6],\r\n  [7, 8, 9]\r\n];\r\n\r\n// Create a visited matrix initialized to false\r\nconst visited = Array.from({ length: grid.length }, () => Array(grid[0].length).fill(false));\r\n\r\n// Start DFS from cell (0, 0)\r\ndfs(grid, 0, 0, visited);\r\n\n"})}),"\n",(0,t.jsx)(n.h2,{id:"2d-breadth-first-search-bfs",children:"2D Breadth-First Search (BFS)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-JavaScript",children:"function bfs(grid, startRow, startCol) {\r\n  const rows = grid.length;\r\n  const cols = grid[0].length;\r\n\r\n  // Direction vectors for moving right, down, left, and up\r\n  const directions = [\r\n    [0, 1],   // right\r\n    [1, 0],   // down\r\n    [0, -1],  // left\r\n    [-1, 0]   // up\r\n  ];\r\n\r\n  // Create a visited matrix initialized to false\r\n  const visited = Array.from({ length: rows }, () => Array(cols).fill(false));\r\n\r\n  // Initialize the queue with the starting cell\r\n  const queue = [[startRow, startCol]];\r\n  visited[startRow][startCol] = true;\r\n\r\n  while (queue.length > 0) {\r\n    // Dequeue the front cell\r\n    const [row, col] = queue.shift();\r\n\r\n    // Print the current cell's value\r\n    console.log(grid[row][col]);\r\n\r\n    // Explore all neighbors\r\n    for (let [dr, dc] of directions) {\r\n      const newRow = row + dr;\r\n      const newCol = col + dc;\r\n\r\n      // Check if the new position is within bounds and not visited\r\n      if (\r\n        newRow >= 0 && newRow < rows &&\r\n        newCol >= 0 && newCol < cols &&\r\n        !visited[newRow][newCol]\r\n      ) {\r\n        // Mark the new cell as visited and enqueue it\r\n        visited[newRow][newCol] = true;\r\n        queue.push([newRow, newCol]);\r\n      }\r\n    }\r\n  }\r\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"2d-dijkstra-shortest-path",children:"2D Dijkstra (Shortest Path)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-JavaScript",children:"function dijkstra(grid, start, end) {\r\n  const rows = grid.length;\r\n  const cols = grid[0].length;\r\n  const distances = Array.from({ length: rows }, () => Array(cols).fill(Infinity));\r\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // Right, Down, Left, Up\r\n  const heap = new MinHeap();\r\n  const [startRow, startCol] = start;\r\n  const [endRow, endCol] = end;\r\n\r\n  distances[startRow][startCol] = 0;\r\n  heap.push([0, startRow, startCol]); //startDistance, row, col\r\n\r\n  while (heap.heap.length > 0) {\r\n    const [currentDist, row, col] = heap.pop();\r\n\r\n    if (row === endRow && col === endCol) {\r\n      return currentDist;\r\n    }\r\n\r\n    for (const [dr, dc] of directions) {\r\n      const newRow = row + dr;\r\n      const newCol = col + dc;\r\n\r\n      if (\r\n        newRow >= 0 &&\r\n        newRow < rows &&\r\n        newCol >= 0 &&\r\n        newCol < cols\r\n      ) {\r\n        const newDist = currentDist + grid[newRow][newCol];\r\n        if (newDist < distances[newRow][newCol]) {\r\n          distances[newRow][newCol] = newDist;\r\n          heap.push([newDist, newRow, newCol]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return -1; // If no path is found\r\n}\n"})})]})}function h(r={}){const{wrapper:n}={...(0,i.R)(),...r.components};return n?(0,t.jsx)(n,{...r,children:(0,t.jsx)(d,{...r})}):d(r)}},8453:(r,n,e)=>{e.d(n,{R:()=>o,x:()=>a});var t=e(6540);const i={},s=t.createContext(i);function o(r){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof r?r(n):{...n,...r}}),[n,r])}function a(r){let n;return n=r.disableParentContext?"function"==typeof r.components?r.components(i):r.components||i:o(r.components),t.createElement(s.Provider,{value:n},r.children)}}}]);