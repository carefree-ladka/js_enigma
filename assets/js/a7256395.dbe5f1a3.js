"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9007],{6599:i=>{i.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Welcome to JSEnigma","href":"/js_enigma/docs/intro","docId":"intro","unlisted":false},{"type":"category","label":"Data Structures & Algorithms","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"0-1 BFS Algorithm","href":"/js_enigma/docs/tutorial-basics/01BFS","docId":"tutorial-basics/01BFS","unlisted":false},{"type":"link","label":"2D Matrix Graph Algorithms","href":"/js_enigma/docs/tutorial-basics/2DGraphAlgorithms","docId":"tutorial-basics/2DGraphAlgorithms","unlisted":false},{"type":"link","label":"Breadth-First Search (BFS) for Trees","href":"/js_enigma/docs/tutorial-basics/BFSTree","docId":"tutorial-basics/BFSTree","unlisted":false},{"type":"link","label":"Backtracking Algorithm","href":"/js_enigma/docs/tutorial-basics/Backtracking","docId":"tutorial-basics/Backtracking","unlisted":false},{"type":"link","label":"Binary Search and Its Variants","href":"/js_enigma/docs/tutorial-basics/BinarySearch","docId":"tutorial-basics/BinarySearch","unlisted":false},{"type":"link","label":"Bit Manipulation Basics","href":"/js_enigma/docs/tutorial-basics/BitManipulation","docId":"tutorial-basics/BitManipulation","unlisted":false},{"type":"link","label":"Boyer\u2013Moore Majority Vote Algorithm","href":"/js_enigma/docs/tutorial-basics/BoyerMoore","docId":"tutorial-basics/BoyerMoore","unlisted":false},{"type":"link","label":"Bucket Sort","href":"/js_enigma/docs/tutorial-basics/BucketSort","docId":"tutorial-basics/BucketSort","unlisted":false},{"type":"link","label":"Counting Sort","href":"/js_enigma/docs/tutorial-basics/CountingSort","docId":"tutorial-basics/CountingSort","unlisted":false},{"type":"link","label":"DFS & BFS on Graphs","href":"/js_enigma/docs/tutorial-basics/DFSBFSGraph","docId":"tutorial-basics/DFSBFSGraph","unlisted":false},{"type":"link","label":"Depth-First Search (DFS) for Trees","href":"/js_enigma/docs/tutorial-basics/DFSTree","docId":"tutorial-basics/DFSTree","unlisted":false},{"type":"link","label":"Dijkstra\'s Algorithm","href":"/js_enigma/docs/tutorial-basics/Dijkstra","docId":"tutorial-basics/Dijkstra","unlisted":false},{"type":"link","label":"Dutch National Flag Algorithm","href":"/js_enigma/docs/tutorial-basics/DutchNationalFlag","docId":"tutorial-basics/DutchNationalFlag","unlisted":false},{"type":"link","label":"Dynamic Programming","href":"/js_enigma/docs/tutorial-basics/DynamicProgramming","docId":"tutorial-basics/DynamicProgramming","unlisted":false},{"type":"link","label":"Euclid\'s Algorithm for Greatest Common Divisor (GCD)","href":"/js_enigma/docs/tutorial-basics/Euclid","docId":"tutorial-basics/Euclid","unlisted":false},{"type":"link","label":"Fenwick Tree Tutorial","href":"/js_enigma/docs/tutorial-basics/Fenwick","docId":"tutorial-basics/Fenwick","unlisted":false},{"type":"link","label":"Fisher-Yates Shuffle Algorithm","href":"/js_enigma/docs/tutorial-basics/FisherYates","docId":"tutorial-basics/FisherYates","unlisted":false},{"type":"link","label":"Flood Fill Algorithm","href":"/js_enigma/docs/tutorial-basics/FloodFill","docId":"tutorial-basics/FloodFill","unlisted":false},{"type":"link","label":"Floyd\'s Cycle Detection Algorithm","href":"/js_enigma/docs/tutorial-basics/FlyodsCycleDetection","docId":"tutorial-basics/FlyodsCycleDetection","unlisted":false},{"type":"link","label":"Frequency Counter Technique","href":"/js_enigma/docs/tutorial-basics/FrequencyCounter","docId":"tutorial-basics/FrequencyCounter","unlisted":false},{"type":"link","label":"Heap\u2019s Algorithm","href":"/js_enigma/docs/tutorial-basics/HeapAlgorithm","docId":"tutorial-basics/HeapAlgorithm","unlisted":false},{"type":"link","label":"Interval Problems","href":"/js_enigma/docs/tutorial-basics/Intervals","docId":"tutorial-basics/Intervals","unlisted":false},{"type":"link","label":"Knuth-Morris-Pratt (KMP) Algorithm","href":"/js_enigma/docs/tutorial-basics/KMPAlgo","docId":"tutorial-basics/KMPAlgo","unlisted":false},{"type":"link","label":"K-Way Merge Pattern","href":"/js_enigma/docs/tutorial-basics/KWayMerge","docId":"tutorial-basics/KWayMerge","unlisted":false},{"type":"link","label":"Kadane\'s Algorithm Tutorial","href":"/js_enigma/docs/tutorial-basics/Kadane","docId":"tutorial-basics/Kadane","unlisted":false},{"type":"link","label":"LRU Cache Design","href":"/js_enigma/docs/tutorial-basics/LRUcache","docId":"tutorial-basics/LRUcache","unlisted":false},{"type":"link","label":"Merge Sort","href":"/js_enigma/docs/tutorial-basics/MergeSort","docId":"tutorial-basics/MergeSort","unlisted":false},{"type":"link","label":"Morris Traversal for Binary Trees","href":"/js_enigma/docs/tutorial-basics/MorrisTraversal","docId":"tutorial-basics/MorrisTraversal","unlisted":false},{"type":"link","label":"Multi-source BFS Algorithm","href":"/js_enigma/docs/tutorial-basics/MultiSourceBFS","docId":"tutorial-basics/MultiSourceBFS","unlisted":false},{"type":"link","label":"Path Sum (Binary Tree)","href":"/js_enigma/docs/tutorial-basics/PathSumBinaryTree","docId":"tutorial-basics/PathSumBinaryTree","unlisted":false},{"type":"link","label":"Prefix Sum","href":"/js_enigma/docs/tutorial-basics/PrefixSum","docId":"tutorial-basics/PrefixSum","unlisted":false},{"type":"link","label":"Queue","href":"/js_enigma/docs/tutorial-basics/Queue","docId":"tutorial-basics/Queue","unlisted":false},{"type":"link","label":"Quick Select Algorithm","href":"/js_enigma/docs/tutorial-basics/QuickSelect","docId":"tutorial-basics/QuickSelect","unlisted":false},{"type":"link","label":"Quick Sort","href":"/js_enigma/docs/tutorial-basics/QuickSort","docId":"tutorial-basics/QuickSort","unlisted":false},{"type":"link","label":"Reservoir Sampling","href":"/js_enigma/docs/tutorial-basics/ReservoirSampling","docId":"tutorial-basics/ReservoirSampling","unlisted":false},{"type":"link","label":"In-Place Reversal of a Linked List","href":"/js_enigma/docs/tutorial-basics/ReverseLinkedList","docId":"tutorial-basics/ReverseLinkedList","unlisted":false},{"type":"link","label":"Segment Tree Tutorial","href":"/js_enigma/docs/tutorial-basics/SegmentTree","docId":"tutorial-basics/SegmentTree","unlisted":false},{"type":"link","label":"Sliding Window Technique","href":"/js_enigma/docs/tutorial-basics/SlidingWindow","docId":"tutorial-basics/SlidingWindow","unlisted":false},{"type":"link","label":"Fast and Slow Pointers Technique","href":"/js_enigma/docs/tutorial-basics/SlowFastPointer","docId":"tutorial-basics/SlowFastPointer","unlisted":false},{"type":"link","label":"Stack","href":"/js_enigma/docs/tutorial-basics/Stack","docId":"tutorial-basics/Stack","unlisted":false},{"type":"link","label":"Topological Sort Tutorial","href":"/js_enigma/docs/tutorial-basics/TopologicalSort","docId":"tutorial-basics/TopologicalSort","unlisted":false},{"type":"link","label":"Trie Data Structure","href":"/js_enigma/docs/tutorial-basics/Trie","docId":"tutorial-basics/Trie","unlisted":false},{"type":"link","label":"Two Pointers Technique","href":"/js_enigma/docs/tutorial-basics/TwoPointers","docId":"tutorial-basics/TwoPointers","unlisted":false},{"type":"link","label":"Union-Find (Disjoint Set Union) Tutorial","href":"/js_enigma/docs/tutorial-basics/UnionFind","docId":"tutorial-basics/UnionFind","unlisted":false}],"href":"/js_enigma/docs/category/data-structures--algorithms"},{"type":"category","label":"Web Development","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"JavaScript Core","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"CSS3 Interview Questions","href":"/js_enigma/docs/tutorial-extras/Core JavaScript/CSS","docId":"tutorial-extras/Core JavaScript/CSS","unlisted":false},{"type":"link","label":"HTML5 Interview Questions","href":"/js_enigma/docs/tutorial-extras/Core JavaScript/HTML","docId":"tutorial-extras/Core JavaScript/HTML","unlisted":false},{"type":"link","label":"JavaScript Interview Questions","href":"/js_enigma/docs/tutorial-extras/Core JavaScript/JS","docId":"tutorial-extras/Core JavaScript/JS","unlisted":false},{"type":"link","label":"React Interview Questions","href":"/js_enigma/docs/tutorial-extras/Core JavaScript/React","docId":"tutorial-extras/Core JavaScript/React","unlisted":false}],"href":"/js_enigma/docs/category/javascript-core"},{"type":"link","label":"Binary Search Tree","href":"/js_enigma/docs/tutorial-extras/BinarySearchTree","docId":"tutorial-extras/BinarySearchTree","unlisted":false}],"href":"/js_enigma/docs/category/web-development"}]},"docs":{"intro":{"id":"intro","title":"Welcome to JSEnigma","description":"It\'s a handy reference for mastering common coding techniques for your next coding interview","sidebar":"tutorialSidebar"},"tutorial-basics/01BFS":{"id":"tutorial-basics/01BFS","title":"0-1 BFS Algorithm","description":"0-1 BFS Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/2DGraphAlgorithms":{"id":"tutorial-basics/2DGraphAlgorithms","title":"2D Matrix Graph Algorithms","description":"A comprehensive guide to 2D DFS, 2D BFS, and 2D Dijkstra algorithms with code examples in JavaScript.","sidebar":"tutorialSidebar"},"tutorial-basics/Backtracking":{"id":"tutorial-basics/Backtracking","title":"Backtracking Algorithm","description":"Backtracking Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/BFSTree":{"id":"tutorial-basics/BFSTree","title":"Breadth-First Search (BFS) for Trees","description":"Breadth-First Search (BFS) for Trees","sidebar":"tutorialSidebar"},"tutorial-basics/BinarySearch":{"id":"tutorial-basics/BinarySearch","title":"Binary Search and Its Variants","description":"Binary Search","sidebar":"tutorialSidebar"},"tutorial-basics/BitManipulation":{"id":"tutorial-basics/BitManipulation","title":"Bit Manipulation Basics","description":"Bit Manipulation Basics","sidebar":"tutorialSidebar"},"tutorial-basics/BoyerMoore":{"id":"tutorial-basics/BoyerMoore","title":"Boyer\u2013Moore Majority Vote Algorithm","description":"Boyer\u2013Moore Majority Vote Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/BucketSort":{"id":"tutorial-basics/BucketSort","title":"Bucket Sort","description":"A detailed guide to understanding and implementing Bucket Sort.","sidebar":"tutorialSidebar"},"tutorial-basics/CountingSort":{"id":"tutorial-basics/CountingSort","title":"Counting Sort","description":"A detailed guide to understanding and implementing Counting Sort.","sidebar":"tutorialSidebar"},"tutorial-basics/DFSBFSGraph":{"id":"tutorial-basics/DFSBFSGraph","title":"DFS & BFS on Graphs","description":"A comprehensive guide to implementing Depth-First Search (DFS) & BFS (Breadth-First Search) on graphs.","sidebar":"tutorialSidebar"},"tutorial-basics/DFSTree":{"id":"tutorial-basics/DFSTree","title":"Depth-First Search (DFS) for Trees","description":"Depth-First Search (DFS) for Trees","sidebar":"tutorialSidebar"},"tutorial-basics/Dijkstra":{"id":"tutorial-basics/Dijkstra","title":"Dijkstra\'s Algorithm","description":"Dijkstra\'s Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/DutchNationalFlag":{"id":"tutorial-basics/DutchNationalFlag","title":"Dutch National Flag Algorithm","description":"Dutch National Flag Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/DynamicProgramming":{"id":"tutorial-basics/DynamicProgramming","title":"Dynamic Programming","description":"Dynamic Programming (DP) is a technique used for solving complex problems by breaking them down into simpler overlapping subproblems. It involves storing the results of these subproblems to avoid redundant computations. There are two main approaches to implementing DP: Top-Down and Bottom-Up.","sidebar":"tutorialSidebar"},"tutorial-basics/Euclid":{"id":"tutorial-basics/Euclid","title":"Euclid\'s Algorithm for Greatest Common Divisor (GCD)","description":"Euclid\'s Algorithm for Greatest Common Divisor (GCD)","sidebar":"tutorialSidebar"},"tutorial-basics/Fenwick":{"id":"tutorial-basics/Fenwick","title":"Fenwick Tree Tutorial","description":"A comprehensive guide to Fenwick Trees with code examples in JavaScript.","sidebar":"tutorialSidebar"},"tutorial-basics/FisherYates":{"id":"tutorial-basics/FisherYates","title":"Fisher-Yates Shuffle Algorithm","description":"The Fisher-Yates Shuffle algorithm is an efficient method for randomly shuffling a finite sequence of items. It ensures that each permutation of the sequence is equally likely.","sidebar":"tutorialSidebar"},"tutorial-basics/FloodFill":{"id":"tutorial-basics/FloodFill","title":"Flood Fill Algorithm","description":"Flood Fill Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/FlyodsCycleDetection":{"id":"tutorial-basics/FlyodsCycleDetection","title":"Floyd\'s Cycle Detection Algorithm","description":"Floyd\'s Cycle Detection Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/FrequencyCounter":{"id":"tutorial-basics/FrequencyCounter","title":"Frequency Counter Technique","description":"Frequency Counter Technique","sidebar":"tutorialSidebar"},"tutorial-basics/HeapAlgorithm":{"id":"tutorial-basics/HeapAlgorithm","title":"Heap\u2019s Algorithm","description":"Heap\u2019s Algorithm is a classic algorithm used to generate all possible permutations of a finite sequence. It is particularly efficient for generating permutations and is widely used in combinatorial algorithms.","sidebar":"tutorialSidebar"},"tutorial-basics/Intervals":{"id":"tutorial-basics/Intervals","title":"Interval Problems","description":"Interval Problems","sidebar":"tutorialSidebar"},"tutorial-basics/Kadane":{"id":"tutorial-basics/Kadane","title":"Kadane\'s Algorithm Tutorial","description":"A comprehensive guide to Kadane\'s Algorithm with code examples in JavaScript.","sidebar":"tutorialSidebar"},"tutorial-basics/KMPAlgo":{"id":"tutorial-basics/KMPAlgo","title":"Knuth-Morris-Pratt (KMP) Algorithm","description":"Brute-Force String Matching","sidebar":"tutorialSidebar"},"tutorial-basics/KWayMerge":{"id":"tutorial-basics/KWayMerge","title":"K-Way Merge Pattern","description":"The k-way merge pattern is a technique used to merge k sorted arrays (or linked lists) into a single sorted array. It\'s commonly used in problems like merging multiple sorted arrays, finding the smallest range covering elements from k lists, and more.","sidebar":"tutorialSidebar"},"tutorial-basics/LRUcache":{"id":"tutorial-basics/LRUcache","title":"LRU Cache Design","description":"An LRU (Least Recently Used) Cache is a data structure that stores a limited number of items and automatically removes the least recently used item when the cache reaches its capacity. It\'s commonly used in scenarios where you need to manage memory by caching results of expensive operations.","sidebar":"tutorialSidebar"},"tutorial-basics/MergeSort":{"id":"tutorial-basics/MergeSort","title":"Merge Sort","description":"A comprehensive guide to understanding and implementing Merge Sort.","sidebar":"tutorialSidebar"},"tutorial-basics/MorrisTraversal":{"id":"tutorial-basics/MorrisTraversal","title":"Morris Traversal for Binary Trees","description":"Morris Traversal","sidebar":"tutorialSidebar"},"tutorial-basics/MultiSourceBFS":{"id":"tutorial-basics/MultiSourceBFS","title":"Multi-source BFS Algorithm","description":"Multi-source BFS Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/PathSumBinaryTree":{"id":"tutorial-basics/PathSumBinaryTree","title":"Path Sum (Binary Tree)","description":"Path Sum (Binary Tree)","sidebar":"tutorialSidebar"},"tutorial-basics/PrefixSum":{"id":"tutorial-basics/PrefixSum","title":"Prefix Sum","description":"A comprehensive guide to understanding and implementing Prefix Sum.","sidebar":"tutorialSidebar"},"tutorial-basics/Queue":{"id":"tutorial-basics/Queue","title":"Queue","description":"A queue is a data structure that follows the First-In-First-Out (FIFO) principle. Elements are added at the rear and removed from the front. Queues are commonly used in scenarios where processing order needs to be maintained.","sidebar":"tutorialSidebar"},"tutorial-basics/QuickSelect":{"id":"tutorial-basics/QuickSelect","title":"Quick Select Algorithm","description":"Quick Select Algorithm","sidebar":"tutorialSidebar"},"tutorial-basics/QuickSort":{"id":"tutorial-basics/QuickSort","title":"Quick Sort","description":"A comprehensive guide to understanding and implementing Quick Sort.","sidebar":"tutorialSidebar"},"tutorial-basics/ReservoirSampling":{"id":"tutorial-basics/ReservoirSampling","title":"Reservoir Sampling","description":"Reservoir Sampling is an algorithm used for randomly selecting a fixed number of items from a stream or a large dataset when the total number of items is not known in advance. It ensures that each item in the stream has an equal probability of being included in the sample.","sidebar":"tutorialSidebar"},"tutorial-basics/ReverseLinkedList":{"id":"tutorial-basics/ReverseLinkedList","title":"In-Place Reversal of a Linked List","description":"In-Place Reversal of a Linked List","sidebar":"tutorialSidebar"},"tutorial-basics/SegmentTree":{"id":"tutorial-basics/SegmentTree","title":"Segment Tree Tutorial","description":"A comprehensive guide to Segment Trees with code examples in JavaScript.","sidebar":"tutorialSidebar"},"tutorial-basics/SlidingWindow":{"id":"tutorial-basics/SlidingWindow","title":"Sliding Window Technique","description":"Sliding Window Technique","sidebar":"tutorialSidebar"},"tutorial-basics/SlowFastPointer":{"id":"tutorial-basics/SlowFastPointer","title":"Fast and Slow Pointers Technique","description":"The Fast and Slow Pointers technique, also known as the Tortoise and Hare algorithm, is a powerful method for solving problems involving linked lists and cyclic structures. It uses two pointers that move at different speeds to detect cycles, find the middle of a list, and solve other related problems efficiently.","sidebar":"tutorialSidebar"},"tutorial-basics/Stack":{"id":"tutorial-basics/Stack","title":"Stack","description":"Introduction","sidebar":"tutorialSidebar"},"tutorial-basics/TopologicalSort":{"id":"tutorial-basics/TopologicalSort","title":"Topological Sort Tutorial","description":"A comprehensive guide to Topological Sort with code examples in JavaScript.","sidebar":"tutorialSidebar"},"tutorial-basics/Trie":{"id":"tutorial-basics/Trie","title":"Trie Data Structure","description":"Trie Data Structure","sidebar":"tutorialSidebar"},"tutorial-basics/TwoPointers":{"id":"tutorial-basics/TwoPointers","title":"Two Pointers Technique","description":"The Two Pointers technique is a popular algorithmic approach used to solve problems involving arrays or lists. It involves using two pointers to traverse the data structure and solve problems efficiently.","sidebar":"tutorialSidebar"},"tutorial-basics/UnionFind":{"id":"tutorial-basics/UnionFind","title":"Union-Find (Disjoint Set Union) Tutorial","description":"A comprehensive guide to Union-Find data structure with code examples in JavaScript.","sidebar":"tutorialSidebar"},"tutorial-extras/BinarySearchTree":{"id":"tutorial-extras/BinarySearchTree","title":"Binary Search Tree","description":"Binary Search Tree (BST)","sidebar":"tutorialSidebar"},"tutorial-extras/Core JavaScript/CSS":{"id":"tutorial-extras/Core JavaScript/CSS","title":"CSS3 Interview Questions","description":"1. Box sizing","sidebar":"tutorialSidebar"},"tutorial-extras/Core JavaScript/HTML":{"id":"tutorial-extras/Core JavaScript/HTML","title":"HTML5 Interview Questions","description":"1. What is the use of DOCTYPE. What if we do not use it in our app?","sidebar":"tutorialSidebar"},"tutorial-extras/Core JavaScript/JS":{"id":"tutorial-extras/Core JavaScript/JS","title":"JavaScript Interview Questions","description":"1. Definition","sidebar":"tutorialSidebar"},"tutorial-extras/Core JavaScript/React":{"id":"tutorial-extras/Core JavaScript/React","title":"React Interview Questions","description":"1. What is React and how it is different from Angular and Vue?","sidebar":"tutorialSidebar"}}}}')}}]);