"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8462],{7336:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>a,contentTitle:()=>o,default:()=>g,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var n=t(4848),s=t(8453);t(2364);const i={title:"Merge Sort",description:"A comprehensive guide to understanding and implementing Merge Sort."},o="Merge Sort",l={id:"tutorial-basics/MergeSort",title:"Merge Sort",description:"A comprehensive guide to understanding and implementing Merge Sort.",source:"@site/docs/tutorial-basics/MergeSort.mdx",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/MergeSort",permalink:"/js_enigma/docs/tutorial-basics/MergeSort",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/tutorial-basics/MergeSort.mdx",tags:[],version:"current",frontMatter:{title:"Merge Sort",description:"A comprehensive guide to understanding and implementing Merge Sort."},sidebar:"tutorialSidebar",previous:{title:"LRU Cache Design",permalink:"/js_enigma/docs/tutorial-basics/LRUcache"},next:{title:"Morris Traversal for Binary Trees",permalink:"/js_enigma/docs/tutorial-basics/MorrisTraversal"}},a={},d=[{value:"How Merge Sort Works",id:"how-merge-sort-works",level:2},{value:"Algorithm Steps",id:"algorithm-steps",level:3},{value:"Pseudocode",id:"pseudocode",level:3}];function h(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.header,{children:(0,n.jsx)(r.h1,{id:"merge-sort",children:"Merge Sort"})}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Merge Sort"})," is a classic sorting algorithm that follows the divide-and-conquer strategy. It divides the input array into smaller sub-arrays, recursively sorts those sub-arrays, and then merges them back together to produce a sorted array. Merge Sort is known for its stability and predictable ",(0,n.jsx)(r.code,{children:"O(n log n)"})," time complexity."]}),"\n",(0,n.jsx)(r.h2,{id:"how-merge-sort-works",children:"How Merge Sort Works"}),"\n",(0,n.jsxs)(r.p,{children:["Merge Sort is a comparison-based sorting algorithm with a time complexity of ",(0,n.jsx)(r.code,{children:"O(n log n)"}),". It is particularly useful for large datasets and is a stable sorting algorithm, meaning it maintains the relative order of equal elements."]}),"\n",(0,n.jsx)(r.h3,{id:"algorithm-steps",children:"Algorithm Steps"}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Divide:"})," Split the array into two halves."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Conquer:"})," Recursively sort each half."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Merge:"})," Combine the sorted halves to produce the final sorted array."]}),"\n"]}),"\n",(0,n.jsx)(r.h3,{id:"pseudocode",children:"Pseudocode"}),"\n",(0,n.jsx)(r.p,{children:"Here\u2019s the pseudocode for Merge Sort:"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-JavaScript",children:"function mergeSort(arr) {\r\n    if (arr.length <= 1) {\r\n        return arr;\r\n    }\r\n\r\n    const middle = Math.floor(arr.length / 2);\r\n    const left = arr.slice(0, middle);\r\n    const right = arr.slice(middle);\r\n\r\n    return merge(mergeSort(left), mergeSort(right));\r\n}\r\n\r\nfunction merge(left, right) {\r\n    let result = [];\r\n    let leftIndex = 0;\r\n    let rightIndex = 0;\r\n\r\n    // Merge the two sorted arrays into one\r\n    while (leftIndex < left.length && rightIndex < right.length) {\r\n        if (left[leftIndex] < right[rightIndex]) {\r\n            result.push(left[leftIndex]);\r\n            leftIndex++;\r\n        } else {\r\n            result.push(right[rightIndex]);\r\n            rightIndex++;\r\n        }\r\n    }\r\n\r\n    // If there are remaining elements in the left array\r\n    while (leftIndex < left.length) {\r\n        result.push(left[leftIndex]);\r\n        leftIndex++;\r\n    }\r\n\r\n    // If there are remaining elements in the right array\r\n    while (rightIndex < right.length) {\r\n        result.push(right[rightIndex]);\r\n        rightIndex++;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n// Example usage\r\nconst array = [3, 6, 8, 10, 1, 2, 1];\r\nconst sortedArray = mergeSort(array);\r\nconsole.log(sortedArray);  // Output: [1, 1, 2, 3, 6, 8, 10]\n"})})]})}function g(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}}}]);