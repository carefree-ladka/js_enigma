"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1355],{4336:(n,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var e=i(4848),o=i(8453);const r={title:"Union-Find (Disjoint Set Union) Tutorial",description:"A comprehensive guide to Union-Find data structure with code examples in JavaScript."},s="Union-Find (Disjoint Set Union) Tutorial",a={id:"tutorial-basics/UnionFind",title:"Union-Find (Disjoint Set Union) Tutorial",description:"A comprehensive guide to Union-Find data structure with code examples in JavaScript.",source:"@site/docs/tutorial-basics/UnionFind.mdx",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/UnionFind",permalink:"/js_enigma/docs/tutorial-basics/UnionFind",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/tutorial-basics/UnionFind.mdx",tags:[],version:"current",frontMatter:{title:"Union-Find (Disjoint Set Union) Tutorial",description:"A comprehensive guide to Union-Find data structure with code examples in JavaScript."},sidebar:"tutorialSidebar",previous:{title:"Two Pointers Technique",permalink:"/js_enigma/docs/tutorial-basics/TwoPointers"},next:{title:"Web Development",permalink:"/js_enigma/docs/category/web-development"}},c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Key Operations",id:"key-operations",level:2},{value:"Implementation",id:"implementation",level:2}];function d(n){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...n.components};return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(t.header,{children:(0,e.jsx)(t.h1,{id:"union-find-disjoint-set-union-tutorial",children:"Union-Find (Disjoint Set Union) Tutorial"})}),"\n",(0,e.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,e.jsx)(t.p,{children:"The Union-Find data structure, also known as Disjoint Set Union (DSU), is a data structure that keeps track of a partition of a set into disjoint (non-overlapping) subsets. It supports two primary operations:"}),"\n",(0,e.jsxs)(t.ol,{children:["\n",(0,e.jsxs)(t.li,{children:[(0,e.jsx)(t.strong,{children:"Union"}),": Merge two subsets into a single subset."]}),"\n",(0,e.jsxs)(t.li,{children:[(0,e.jsx)(t.strong,{children:"Find"}),": Determine which subset a particular element is in."]}),"\n"]}),"\n",(0,e.jsx)(t.p,{children:"Union-Find is particularly useful in scenarios involving network connectivity, Kruskal's algorithm for finding the Minimum Spanning Tree, and various other graph-related problems."}),"\n",(0,e.jsx)(t.h2,{id:"key-operations",children:"Key Operations"}),"\n",(0,e.jsxs)(t.ol,{children:["\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.strong,{children:"Find"}),": This operation determines the representative or root of the set that contains the given element. Path compression is often used to speed up future queries."]}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["\n",(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.strong,{children:"Union"}),": This operation merges two subsets into a single subset. Union by rank (or size) is commonly used to keep the tree flat and efficient."]}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(t.h2,{id:"implementation",children:"Implementation"}),"\n",(0,e.jsx)(t.p,{children:"Here\u2019s a basic implementation of the Union-Find data structure in JavaScript:"}),"\n",(0,e.jsx)(t.pre,{children:(0,e.jsx)(t.code,{className:"language-javascript",children:"class UnionFind {\r\n  constructor(size) {\r\n    this.parent = Array.from({ length: size }, (_, i) => i);\r\n    this.rank = Array(size).fill(0);\r\n  }\r\n\r\n  // Find the root of the set containing element x with path compression\r\n  find(x) {\r\n    if (this.parent[x] !== x) {\r\n      this.parent[x] = this.find(this.parent[x]); // Path compression\r\n    }\r\n    return this.parent[x];\r\n  }\r\n\r\n  // Union the sets containing elements x and y with union by rank\r\n  union(x, y) {\r\n    const rootX = this.find(x);\r\n    const rootY = this.find(y);\r\n\r\n    if (rootX !== rootY) {\r\n      // Union by rank\r\n      if (this.rank[rootX] > this.rank[rootY]) {\r\n        this.parent[rootY] = rootX;\r\n      } else if (this.rank[rootX] < this.rank[rootY]) {\r\n        this.parent[rootX] = rootY;\r\n      } else {\r\n        this.parent[rootY] = rootX;\r\n        this.rank[rootX] += 1;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Example Usage\r\nconst uf = new UnionFind(10);\r\n\r\n// Union operations\r\nuf.union(1, 2);\r\nuf.union(2, 3);\r\nuf.union(4, 5);\r\n\r\n// Find operations\r\nconsole.log(uf.find(1)); // Output: 1 (root of the set containing 1)\r\nconsole.log(uf.find(3)); // Output: 1 (root of the set containing 3)\r\nconsole.log(uf.find(5)); // Output: 5 (root of the set containing 5)\n"})})]})}function u(n={}){const{wrapper:t}={...(0,o.R)(),...n.components};return t?(0,e.jsx)(t,{...n,children:(0,e.jsx)(d,{...n})}):d(n)}},8453:(n,t,i)=>{i.d(t,{R:()=>s,x:()=>a});var e=i(6540);const o={},r=e.createContext(o);function s(n){const t=e.useContext(r);return e.useMemo((function(){return"function"==typeof n?n(t):{...t,...n}}),[t,n])}function a(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),e.createElement(r.Provider,{value:t},n.children)}}}]);