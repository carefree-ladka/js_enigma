"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7742],{895:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>h});var n=t(4848),o=t(8453);const s={title:"Breadth-First Search (BFS) for Trees"},l=void 0,i={id:"tutorial-basics/BFSTree",title:"Breadth-First Search (BFS) for Trees",description:"Breadth-First Search (BFS) for Trees",source:"@site/docs/tutorial-basics/BFSTree.mdx",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/BFSTree",permalink:"/docs/tutorial-basics/BFSTree",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/tutorial-basics/BFSTree.mdx",tags:[],version:"current",frontMatter:{title:"Breadth-First Search (BFS) for Trees"},sidebar:"tutorialSidebar",previous:{title:"2D Matrix Graph Algorithms",permalink:"/docs/tutorial-basics/2DGraphAlgorithms"},next:{title:"Backtracking Algorithm",permalink:"/docs/tutorial-basics/Backtracking"}},a={},h=[{value:"Breadth-First Search (BFS) for Trees",id:"breadth-first-search-bfs-for-trees",level:2},{value:"Overview",id:"overview",level:3},{value:"Algorithm Steps",id:"algorithm-steps",level:3},{value:"Example Implementation",id:"example-implementation",level:3},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach",id:"approach",level:2},{value:"Example",id:"example",level:3}];function d(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.h2,{id:"breadth-first-search-bfs-for-trees",children:"Breadth-First Search (BFS) for Trees"}),"\n",(0,n.jsx)(r.p,{children:"Breadth-First Search (BFS) is an algorithm used to traverse or search through tree or graph structures. It explores all nodes at the present depth level before moving on to nodes at the next depth level. BFS is particularly useful for finding the shortest path in unweighted graphs or trees."}),"\n",(0,n.jsx)(r.h3,{id:"overview",children:"Overview"}),"\n",(0,n.jsx)(r.p,{children:"In BFS, we start from the root (or any arbitrary node in a graph) and explore all of its neighbors at the present depth level before moving on to nodes at the next depth level. This traversal is typically implemented using a queue data structure to keep track of the nodes to be explored."}),"\n",(0,n.jsx)(r.h3,{id:"algorithm-steps",children:"Algorithm Steps"}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Initialize"}),": Create a queue and enqueue the root node. Also, mark the root node as visited."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Explore"}),": Dequeue a node from the queue and process it."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Enqueue Neighbors"}),": Enqueue all unvisited child nodes (or neighbors) of the dequeued node."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Repeat"}),": Continue the process until the queue is empty."]}),"\n"]}),"\n",(0,n.jsx)(r.h3,{id:"example-implementation",children:"Example Implementation"}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Code Example"}),":"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-javascript",children:"class TreeNode {\r\n  constructor(val) {\r\n    this.val = val;\r\n    this.left = null;\r\n    this.right = null;\r\n  }\r\n}\r\n\r\n/**\r\n * Perform BFS traversal on a tree.\r\n * @param {TreeNode} root - The root of the tree.\r\n * @return {number[]} - The values of the nodes in BFS order.\r\n */\r\nconst bfsTraversal = (root) => {\r\n  if (!root) return [];\r\n  \r\n  const result = [];\r\n  const queue = [root];\r\n  \r\n  while (queue.length > 0) {\r\n    const node = queue.shift(); // Dequeue the front node\r\n    result.push(node.val); // Process the node\r\n    \r\n    // Enqueue the child nodes\r\n    if (node.left) queue.push(node.left);\r\n    if (node.right) queue.push(node.right);\r\n  }\r\n  \r\n  return result;\r\n};\r\n\r\n// Example usage:\r\nconst root = new TreeNode(1);\r\nroot.left = new TreeNode(2);\r\nroot.right = new TreeNode(3);\r\nroot.left.left = new TreeNode(4);\r\nroot.left.right = new TreeNode(5);\r\nroot.right.left = new TreeNode(6);\r\nroot.right.right = new TreeNode(7);\r\n\r\n/* \r\n                     1\r\n                    / \\\r\n                   2   3\r\n                  / \\ / \\\r\n                 4  5 6  7\r\n*/\r\n\r\nconsole.log(bfsTraversal(root)); // Output: [1, 2, 3, 4, 5, 6, 7]\n"})}),"\n",(0,n.jsx)(r.h1,{id:"bfs-level-order-traversal",children:"BFS Level Order Traversal"}),"\n",(0,n.jsxs)(r.p,{children:[(0,n.jsx)(r.strong,{children:"Breadth-First Search (BFS)"})," is a graph traversal algorithm that explores nodes level by level. When applied to a binary tree, it processes all nodes at the present depth level before moving on to the nodes at the next depth level."]}),"\n",(0,n.jsx)(r.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,n.jsx)(r.p,{children:"Given a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level)."}),"\n",(0,n.jsx)(r.h2,{id:"approach",children:"Approach"}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Queue Data Structure:"})," Use a queue to keep track of nodes at the current level."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Level-by-Level Traversal:"})," Start from the root, and for each node, enqueue its children. Dequeue a node to visit it and move to the next level."]}),"\n"]}),"\n",(0,n.jsx)(r.h3,{id:"example",children:"Example"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-JavaScript",children:"class TreeNode {\r\n  constructor(val, left = null, right = null) {\r\n    this.val = val;\r\n    this.left = left;\r\n    this.right = right;\r\n  }\r\n}\r\n\r\nfunction levelOrder(root) {\r\n  const result = [];\r\n  if (!root) return result;\r\n\r\n  const queue = [root];\r\n\r\n  while (queue.length > 0) {\r\n    const levelSize = queue.length;\r\n    const currentLevel = [];\r\n\r\n    for (let i = 0; i < levelSize; i++) {\r\n      const node = queue.shift();\r\n      currentLevel.push(node.val);\r\n\r\n      if (node.left) queue.push(node.left);\r\n      if (node.right) queue.push(node.right);\r\n    }\r\n\r\n    result.push(currentLevel);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// Example usage\r\nconst root = new TreeNode(3);\r\nroot.left = new TreeNode(9);\r\nroot.right = new TreeNode(20, new TreeNode(15), new TreeNode(7));\r\n\r\nconst result = levelOrder(root);\r\nconsole.log(result); // Output: [[3], [9, 20], [15, 7]]\n"})})]})}function u(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,r,t)=>{t.d(r,{R:()=>l,x:()=>i});var n=t(6540);const o={},s=n.createContext(o);function l(e){const r=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),n.createElement(s.Provider,{value:r},e.children)}}}]);