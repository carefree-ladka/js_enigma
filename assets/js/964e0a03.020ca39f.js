"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8881],{6037:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>c,toc:()=>h});var s=n(4848),i=n(8453);const r={title:"LRU Cache Design"},a="LRU Cache",c={id:"tutorial-basics/LRUcache",title:"LRU Cache Design",description:"An LRU (Least Recently Used) Cache is a data structure that stores a limited number of items and automatically removes the least recently used item when the cache reaches its capacity. It's commonly used in scenarios where you need to manage memory by caching results of expensive operations.",source:"@site/docs/tutorial-basics/LRUcache.mdx",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/LRUcache",permalink:"/docs/tutorial-basics/LRUcache",draft:!1,unlisted:!1,editUrl:"https://github.com/carefree-ladka/docs/tutorial-basics/LRUcache.mdx",tags:[],version:"current",frontMatter:{title:"LRU Cache Design"},sidebar:"tutorialSidebar",previous:{title:"Kadane's Algorithm Tutorial",permalink:"/docs/tutorial-basics/Kadane"},next:{title:"Merge Sort",permalink:"/docs/tutorial-basics/MergeSort"}},o={},h=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Example",id:"example",level:3},{value:"Using Ordered Map",id:"using-ordered-map",level:3},{value:"Using Doubly LinkedList",id:"using-doubly-linkedlist",level:3},{value:"Complexity Analysis",id:"complexity-analysis",level:3}];function l(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"lru-cache",children:"LRU Cache"})}),"\n",(0,s.jsxs)(t.p,{children:["An ",(0,s.jsx)(t.strong,{children:"LRU (Least Recently Used) Cache"})," is a data structure that stores a limited number of items and automatically removes the least recently used item when the cache reaches its capacity. It's commonly used in scenarios where you need to manage memory by caching results of expensive operations."]}),"\n",(0,s.jsx)(t.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,s.jsxs)(t.p,{children:["Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the ",(0,s.jsx)(t.code,{children:"LRUCache"})," class:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"LRUCache(int capacity)"})," initializes the LRU cache with a positive size capacity."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"int get(int key)"})," returns the value of the key if it exists in the cache, otherwise returns -1."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"void put(int key, int value)"})," updates the value of the key if it exists. Otherwise, adds the key-value pair to the cache. If the number of keys exceeds the capacity, evict the least recently used key."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"example",children:"Example"}),"\n",(0,s.jsx)(t.h3,{id:"using-ordered-map",children:"Using Ordered Map"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-Javascript",children:"class LRUCache {\r\n    constructor(capacity) {\r\n        this.capacity = capacity;\r\n        this.cache = new Map();\r\n    }\r\n\r\n    get(key) {\r\n        if (!this.cache.has(key)) return -1;\r\n\r\n        const value = this.cache.get(key);\r\n        // Refresh the key by deleting and re-adding it, moving it to the end of the Map\r\n        this.cache.delete(key);\r\n        this.cache.set(key, value);\r\n\r\n        return value;\r\n    }\r\n\r\n    put(key, value) {\r\n        if (this.cache.has(key)) {\r\n            // If the key already exists, delete it to refresh its position\r\n            this.cache.delete(key);\r\n        } else if (this.cache.size === this.capacity) {\r\n            // If the cache is at capacity, remove the least recently used key (the first one)\r\n            const firstKey = this.cache.keys().next().value;\r\n            this.cache.delete(firstKey);\r\n        }\r\n        // Add the new key-value pair to the end of the Map\r\n        this.cache.set(key, value);\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"using-doubly-linkedlist",children:"Using Doubly LinkedList"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-Javascript",children:"class Node {\r\n    constructor(key, value) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.next = null;\r\n        this.prev = null;\r\n    }\r\n}\r\n\r\nclass DoublyLinkedList {\r\n    constructor() {\r\n        this.head = new Node(0, 0);\r\n        this.tail = new Node(0, 0);\r\n        this.head.next = this.tail;\r\n        this.tail.prev = this.head;\r\n    }\r\n    moveToFront = (node) => {\r\n        node.next = this.head.next;\r\n        node.next.prev = node;\r\n        this.head.next = node;\r\n        node.prev = this.head;\r\n    };\r\n    removeNode = (node) => {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    };\r\n    move2Front = (node) => {\r\n        this.removeNode(node)\r\n        this.moveToFront(node)\r\n    }\r\n    getTail = () => this.tail.prev;\r\n}\r\n\r\nclass LRUCache {\r\n    constructor(capacity) {\r\n        this.capacity = capacity;\r\n        this.cache = new Map();\r\n        this.list = new DoublyLinkedList();\r\n    }\r\n    get = (key) => {\r\n        if (!this.cache.has(key)) return -1;\r\n        const node = this.cache.get(key);\r\n        this.list.move2Front(node);\r\n        return node.value;\r\n    };\r\n    put = (key, value) => {\r\n        if (this.cache.has(key)) {\r\n            const node = this.cache.get(key);\r\n            node.value = value;\r\n            this.list.move2Front(node);\r\n        } else {\r\n            if (this.cache.size >= this.capacity) {\r\n                const tailNode = this.list.getTail();\r\n                this.list.removeNode(tailNode);\r\n                this.cache.delete(tailNode.key);\r\n            }\r\n            const newNode = new Node(key, value);\r\n            this.list.moveToFront(newNode);\r\n            this.cache.set(key, newNode);\r\n        }\r\n    };\r\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"complexity-analysis",children:"Complexity Analysis"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Time Complexity:"})," O(1) for both ",(0,s.jsx)(t.code,{children:"get"})," and ",(0,s.jsx)(t.code,{children:"put"})," operations. Access and updating the cache is constant time because of the hash map and linked list."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Space Complexity:"})," O(capacity) for storing key-value pairs in the cache and the nodes in the linked list."]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var s=n(6540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);